"""A Lark Transformer for transforming a Lark parse tree into a Python dict"""
import re
import sys
from collections import namedtuple
from typing import List, Dict, Any

from lark.tree import Meta
from lark.visitors import Transformer, Discard, _DiscardType, v_args


HEREDOC_PATTERN = re.compile(r"<<([a-zA-Z][a-zA-Z0-9._-]+)\n([\s\S]*)\1", re.S)
HEREDOC_TRIM_PATTERN = re.compile(r"<<-([a-zA-Z][a-zA-Z0-9._-]+)\n([\s\S]*)\1", re.S)


START_LINE = "__start_line__"
END_LINE = "__end_line__"
START_COLUMN = "__start_column__"
END_COLUMN = "__end_column__"
COMMENTS = "__comments__"


Attribute = namedtuple(
    "Attribute", 
    ("key", "value", "start_line", "end_line", "start_column", "end_column")
)
Comment = namedtuple(
    "Comment", 
    ("value", "start_line", "end_line")
)

comments = []
id = None


# pylint: disable=missing-function-docstring,unused-argument
class DictTransformer(Transformer):
    """Takes a syntax tree generated by the parser and
    transforms it to a dict.
    """

    with_meta: bool

    def __init__(self, with_meta: bool = False):
        """
        :param with_meta: If set to true then adds `__start_line__` and `__end_line__`
        parameters to the output dict. Default to false.
        """
        self.with_meta = with_meta
        super().__init__()

    def float_lit(self, args: List) -> float:
        return float("".join([str(arg) for arg in args]))

    def int_lit(self, args: List) -> int:
        return int("".join([str(arg) for arg in args]))

    def expr_term(self, args: List) -> Any:
        args = self.strip_new_line_tokens(args)

        #
        if args[0] == "true":
            return True
        if args[0] == "false":
            return False
        if args[0] == "null":
            return None

        # if the expression starts with a paren then unwrap it
        if args[0] == "(":
            return args[1]
        # otherwise return the value itself
        return args[0]

    def index_expr_term(self, args: List) -> str:
        args = self.strip_new_line_tokens(args)
        return f"{args[0]}{args[1]}"

    def index(self, args: List) -> str:
        args = self.strip_new_line_tokens(args)
        return f"[{args[0]}]"

    def get_attr_expr_term(self, args: List) -> str:
        return f"{args[0]}{args[1]}"

    def get_attr(self, args: List) -> str:
        return f".{args[0]}"

    def attr_splat_expr_term(self, args: List) -> str:
        return f"{args[0]}{args[1]}"

    def attr_splat(self, args: List) -> str:
        args_str = "".join(str(arg) for arg in args)
        return f".*{args_str}"

    def full_splat_expr_term(self, args: List) -> str:
        return f"{args[0]}{args[1]}"

    def full_splat(self, args: List) -> str:
        args_str = "".join(str(arg) for arg in args)
        return f"[*]{args_str}"

    def tuple(self, args: List) -> List:
        result = []
        for arg in self.strip_new_line_tokens(args):
            result.append(self.to_string_dollar(arg))
        return result

    @v_args(meta=True)
    def object_elem(self, meta: Meta, args: List) -> Dict:
        # This returns a dict with a single key/value pair to make it easier to merge these
        # into a bigger dict that is returned by the "object" function
        key = self.strip_quotes(args[0])
        value = self.to_string_dollar(args[1])
        d: Dict[str, Any] = {}
        d["value"] = value
        if self.with_meta:
            d[START_LINE] = meta.line
            d[END_LINE] = meta.end_line
            d[START_COLUMN] = meta.column
            d[END_COLUMN] = meta.end_column
        return {key:d}

    def object(self, args: List) -> Dict:
        args = self.strip_new_line_tokens(args)
        result: Dict[str, Any] = {}

        for arg in args:
            result.update(arg)
        return result

    def function_call(self, args: List) -> str:
        def remove_meta_info(arg):
            if isinstance(arg, dict):
                d = {}
                for n, v in arg.items():
                    if isinstance(v, dict) or isinstance(v, list):
                        d[n] = remove_meta_info(v)
                    else:
                        if n in [START_LINE, END_LINE, START_COLUMN, END_COLUMN]:
                            continue
                        else:
                            d[n] = v
                return d
            elif isinstance(arg, list):
                l = []
                for a in arg:
                    l.append(remove_meta_info(a))
                return l
            else:
                return arg

        def simplify_format(arg):
            if isinstance(arg, dict):
                d = {}
                for n, v in arg.items():
                    if n == "value":
                        if isinstance(v, dict) or isinstance(v, list):
                            return simplify_format(v)
                        else:
                            return v
                    else:
                        if isinstance(v, dict) or isinstance(v, list):
                            d[n] = simplify_format(v)
                        else:
                            d[n] = v
                return d
            elif isinstance(arg, list):
                l = []
                for a in arg:
                    l.append(simplify_format(a))
                return l
            else:
                return arg

        args = self.strip_new_line_tokens(args)
        args_str = ""
        if len(args) > 1:
            arguments = simplify_format(remove_meta_info(args[1]))
            args_str = ", ".join([str(arg) for arg in arguments if arg is not Discard])
        return f"{args[0]}({args_str})"

    def arguments(self, args: List) -> List:
        return args

    def new_line_and_or_comma(self, args: List) -> _DiscardType:
        return Discard

    @v_args(meta=True)
    def block(self, meta: Meta, args: List) -> Dict:
        *block_labels, block_body = args
        result: Dict[str, Any] = block_body
        if self.with_meta:
            result.update(
                {
                    START_LINE: meta.line,
                    END_LINE: meta.end_line,
                    START_COLUMN: meta.column,
                    END_COLUMN: meta.end_column,
                }
            )

        # create nested dict. i.e. {label1: {label2: {labelN: result}}}
        for label in reversed(block_labels):
            label_str = self.strip_quotes(label)
            result = {label_str: result}

        return result

    @v_args(meta=True)
    def attribute(self, meta: Meta, args: List) -> Attribute:
        key = str(args[0])
        if key.startswith('"') and key.endswith('"'):
            key = key[1:-1]
        value = self.to_string_dollar(args[1])
        if self.with_meta:
            return Attribute(
                key, value, meta.line, meta.end_line, meta.column, meta.end_column
            )
        return Attribute(key, value, 0, 0, 0, 0)

    def conditional(self, args: List) -> str:
        args = self.strip_new_line_tokens(args)
        return f"{args[0]} ? {args[1]} : {args[2]}"

    def binary_op(self, args: List) -> str:
        return " ".join([str(arg) for arg in args])

    def unary_op(self, args: List) -> str:
        return "".join([str(arg) for arg in args])

    def binary_term(self, args: List) -> str:
        args = self.strip_new_line_tokens(args)
        return " ".join([str(arg) for arg in args])

    def body(self, args: List) -> Dict[str, List]:
        # See https://github.com/hashicorp/hcl/blob/main/hclsyntax/spec.md#bodies
        # ---
        # A body is a collection of associated attributes and blocks.
        #
        # An attribute definition assigns a value to a particular attribute
        # name within a body. Each distinct attribute name may be defined no
        # more than once within a single body.
        #
        # A block creates a child body that is annotated with a block type and
        # zero or more block labels. Blocks create a structural hierarchy which
        # can be interpreted by the calling application.
        # ---
        #
        # There can be more than one child body with the same block type and
        # labels. This means that all blocks (even when there is only one)
        # should be transformed into lists of blocks.
        def add_comments():
            global comments
            if COMMENTS not in result:
                result[COMMENTS] = []
            for c in comments:
                d: Dict[str, Any] = {}
                d["value"] = c.value
                if self.with_meta:
                    d[START_LINE] = c.start_line
                    d[END_LINE] = c.end_line
                result[COMMENTS].append(d)
            comments = []
        
        args = self.strip_new_line_tokens(args)
        attributes = set()
        result: Dict[str, Any] = {}
        global comments
        global id

        if args == [] and id == None and comments != []:
            add_comments()
        id = None

        for arg in args:
            if isinstance(arg, Attribute):
                if arg.key in result:
                    raise RuntimeError(f"{arg.key} already defined")
                d: Dict[str, Any] = {}
                d["value"] = arg.value
                if self.with_meta:
                    d[START_LINE] = arg.start_line
                    d[END_LINE] = arg.end_line
                    d[START_COLUMN] = arg.start_column
                    d[END_COLUMN] = arg.end_column
                result[arg.key] = d
                attributes.add(arg.key)
            else:
                # This is a block.
                for key, value in arg.items():
                    key = str(key)
                    if key in result:
                        if key in attributes:
                            raise RuntimeError(f"{key} already defined")
                        result[key].append(value)
                    else:
                        result[key] = [value]
                    
                    if key in ["resource", "data", "variable", "module", "output", "locals"] and comments != []:
                        add_comments()

        return result

    def start(self, args: List) -> Dict:
        args = self.strip_new_line_tokens(args)
        return args[0]

    def binary_operator(self, args: List) -> str:
        return str(args[0])

    def heredoc_template(self, args: List) -> str:
        match = HEREDOC_PATTERN.match(str(args[0]))
        if not match:
            raise RuntimeError(f"Invalid Heredoc token: {args[0]}")

        trim_chars = "\n\t "
        return f'"{match.group(2).rstrip(trim_chars)}"'

    def heredoc_template_trim(self, args: List) -> str:
        # See https://github.com/hashicorp/hcl2/blob/master/hcl/hclsyntax/spec.md#template-expressions
        # This is a special version of heredocs that are declared with "<<-"
        # This will calculate the minimum number of leading spaces in each line of a heredoc
        # and then remove that number of spaces from each line
        match = HEREDOC_TRIM_PATTERN.match(str(args[0]))
        if not match:
            raise RuntimeError(f"Invalid Heredoc token: {args[0]}")

        trim_chars = "\n\t "
        text = match.group(2).rstrip(trim_chars)
        lines = text.split("\n")

        # calculate the min number of leading spaces in each line
        min_spaces = sys.maxsize
        for line in lines:
            leading_spaces = len(line) - len(line.lstrip(" "))
            min_spaces = min(min_spaces, leading_spaces)

        # trim off that number of leading spaces from each line
        lines = [line[min_spaces:] for line in lines]

        return '"%s"' % "\n".join(lines)

    @v_args(meta=True)
    def new_line_or_comment(self, meta: Meta, args: List) -> _DiscardType:
        global comments
        line = 0
        for arg in args:
            if arg == '\n':
                line += 1
            else:
                if self.with_meta:
                    start_line = meta.line + line
                    end_line = start_line + len(arg.splitlines()) - 1
                    comments.append(Comment(arg.value, start_line, end_line))
                else:
                    comments.append(Comment(arg.value, 0, 0))
                if len(arg.splitlines()) > 1:   
                    line += len(arg.splitlines()) - 1 # multiline comment does not contain the final \n
                else: 
                    line += 1
                
        return Discard
            

    def for_tuple_expr(self, args: List) -> str:
        args = self.strip_new_line_tokens(args)
        for_expr = " ".join([str(arg) for arg in args[1:-1]])
        return f"[{for_expr}]"

    def for_intro(self, args: List) -> str:
        args = self.strip_new_line_tokens(args)
        return " ".join([str(arg) for arg in args])

    def for_cond(self, args: List) -> str:
        args = self.strip_new_line_tokens(args)
        return " ".join([str(arg) for arg in args])

    def for_object_expr(self, args: List) -> str:
        args = self.strip_new_line_tokens(args)
        for_expr = " ".join([str(arg) for arg in args[1:-1]])
        # doubled curly braces stands for inlining the braces
        # and the third pair of braces is for the interpolation
        # e.g. f"{2 + 2} {{2 + 2}}" == "4 {2 + 2}"
        return f"{{{for_expr}}}"

    def strip_new_line_tokens(self, args: List) -> List:
        """
        Remove new line and Discard tokens.
        The parser will sometimes include these in the tree so we need to strip them out here
        """
        return [arg for arg in args if arg != "\n" and arg is not Discard]

    def to_string_dollar(self, value: Any) -> Any:
        """Wrap a string in ${ and }"""
        if isinstance(value, str):
            if value.startswith('"') and value.endswith('"'):
                return str(value)[1:-1]
            return f"${{{value}}}"
        return value

    def strip_quotes(self, value: Any) -> Any:
        """Remove quote characters from the start and end of a string"""
        if isinstance(value, str):
            if value.startswith('"') and value.endswith('"'):
                return str(value)[1:-1]
        return value

    def identifier(self, value: Any) -> Any:
        # Making identifier a token by capitalizing it to IDENTIFIER
        # seems to return a token object instead of the str
        # So treat it like a regular rule
        # In this case we just convert the whole thing to a string
        global id
        id = str(value[0])
        return str(value[0])
